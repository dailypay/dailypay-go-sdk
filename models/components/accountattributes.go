// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/dailypay/dailypay-go-sdk/internal/utils"
)

// AccountAttributesDepositoryAccountVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesDepositoryAccountVerificationStatus string

const (
	AccountAttributesDepositoryAccountVerificationStatusVerificationPending AccountAttributesDepositoryAccountVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesDepositoryAccountVerificationStatusVerificationFailed  AccountAttributesDepositoryAccountVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesDepositoryAccountVerificationStatusVerified            AccountAttributesDepositoryAccountVerificationStatus = "VERIFIED"
)

func (e AccountAttributesDepositoryAccountVerificationStatus) ToPointer() *AccountAttributesDepositoryAccountVerificationStatus {
	return &e
}
func (e *AccountAttributesDepositoryAccountVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesDepositoryAccountVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositoryAccountVerificationStatus: %v", v)
	}
}

type AccountAttributesDepositoryAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	// This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
	// **Special note for Earnings Balance accounts:**
	// If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesDepositoryAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesDepositoryAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"currency"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesDepositoryAccountBalances) GetAvailable() *int64 {
	if a == nil {
		return nil
	}
	return a.Available
}

func (a *AccountAttributesDepositoryAccountBalances) GetCurrent() *int64 {
	if a == nil {
		return nil
	}
	return a.Current
}

func (a *AccountAttributesDepositoryAccountBalances) GetCurrency() string {
	if a == nil {
		return ""
	}
	return a.Currency
}

type AccountAttributesDepositoryAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesDepositoryAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesDepositoryAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesDepositoryAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if a == nil {
		return []TransferDestinationCapability{}
	}
	return a.TransferDestination
}

// AccountAttributesDepositorySubtype - The subtype of the account.
type AccountAttributesDepositorySubtype string

const (
	AccountAttributesDepositorySubtypeSavings  AccountAttributesDepositorySubtype = "SAVINGS"
	AccountAttributesDepositorySubtypeChecking AccountAttributesDepositorySubtype = "CHECKING"
)

func (e AccountAttributesDepositorySubtype) ToPointer() *AccountAttributesDepositorySubtype {
	return &e
}
func (e *AccountAttributesDepositorySubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SAVINGS":
		fallthrough
	case "CHECKING":
		*e = AccountAttributesDepositorySubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositorySubtype: %v", v)
	}
}

// AccountAttributesDepositoryDepositoryAccountDetails - The banking details of the account and account holder.
type AccountAttributesDepositoryDepositoryAccountDetails struct {
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The routing number of the bank that holds this account. Responses from this API that return this number are masked to the last four digits.
	RoutingNumber string `json:"routing_number"`
	// The account number. Responses from this API that return this number are masked to the last four digits.
	AccountNumber string `json:"account_number"`
}

func (a AccountAttributesDepositoryDepositoryAccountDetails) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesDepositoryDepositoryAccountDetails) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"first_name", "last_name", "routing_number", "account_number"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesDepositoryDepositoryAccountDetails) GetFirstName() string {
	if a == nil {
		return ""
	}
	return a.FirstName
}

func (a *AccountAttributesDepositoryDepositoryAccountDetails) GetLastName() string {
	if a == nil {
		return ""
	}
	return a.LastName
}

func (a *AccountAttributesDepositoryDepositoryAccountDetails) GetRoutingNumber() string {
	if a == nil {
		return ""
	}
	return a.RoutingNumber
}

func (a *AccountAttributesDepositoryDepositoryAccountDetails) GetAccountNumber() string {
	if a == nil {
		return ""
	}
	return a.AccountNumber
}

// Depository - An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
type Depository struct {
	// A code that indicates the status of an account that is a destination for funds.
	AccountVerificationStatus AccountAttributesDepositoryAccountVerificationStatus `json:"verification_status"`
	AccountBalances           AccountAttributesDepositoryAccountBalances           `json:"balances"`
	AccountCapabilities       AccountAttributesDepositoryAccountCapabilities       `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"DEPOSITORY" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesDepositorySubtype `json:"subtype"`
	// The banking details of the account and account holder.
	DepositoryAccountDetails AccountAttributesDepositoryDepositoryAccountDetails `json:"details"`
}

func (d Depository) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Depository) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (d *Depository) GetAccountVerificationStatus() AccountAttributesDepositoryAccountVerificationStatus {
	if d == nil {
		return AccountAttributesDepositoryAccountVerificationStatus("")
	}
	return d.AccountVerificationStatus
}

func (d *Depository) GetAccountBalances() AccountAttributesDepositoryAccountBalances {
	if d == nil {
		return AccountAttributesDepositoryAccountBalances{}
	}
	return d.AccountBalances
}

func (d *Depository) GetAccountCapabilities() AccountAttributesDepositoryAccountCapabilities {
	if d == nil {
		return AccountAttributesDepositoryAccountCapabilities{}
	}
	return d.AccountCapabilities
}

func (d *Depository) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *Depository) GetAccountType() string {
	return "DEPOSITORY"
}

func (d *Depository) GetSubtype() AccountAttributesDepositorySubtype {
	if d == nil {
		return AccountAttributesDepositorySubtype("")
	}
	return d.Subtype
}

func (d *Depository) GetDepositoryAccountDetails() AccountAttributesDepositoryDepositoryAccountDetails {
	if d == nil {
		return AccountAttributesDepositoryDepositoryAccountDetails{}
	}
	return d.DepositoryAccountDetails
}

// AccountAttributesEarningsBalanceAccountVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesEarningsBalanceAccountVerificationStatus string

const (
	AccountAttributesEarningsBalanceAccountVerificationStatusVerificationPending AccountAttributesEarningsBalanceAccountVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesEarningsBalanceAccountVerificationStatusVerificationFailed  AccountAttributesEarningsBalanceAccountVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesEarningsBalanceAccountVerificationStatusVerified            AccountAttributesEarningsBalanceAccountVerificationStatus = "VERIFIED"
)

func (e AccountAttributesEarningsBalanceAccountVerificationStatus) ToPointer() *AccountAttributesEarningsBalanceAccountVerificationStatus {
	return &e
}
func (e *AccountAttributesEarningsBalanceAccountVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesEarningsBalanceAccountVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesEarningsBalanceAccountVerificationStatus: %v", v)
	}
}

type AccountAttributesEarningsBalanceAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	// This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
	// **Special note for Earnings Balance accounts:**
	// If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesEarningsBalanceAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesEarningsBalanceAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"currency"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesEarningsBalanceAccountBalances) GetAvailable() *int64 {
	if a == nil {
		return nil
	}
	return a.Available
}

func (a *AccountAttributesEarningsBalanceAccountBalances) GetCurrent() *int64 {
	if a == nil {
		return nil
	}
	return a.Current
}

func (a *AccountAttributesEarningsBalanceAccountBalances) GetCurrency() string {
	if a == nil {
		return ""
	}
	return a.Currency
}

type AccountAttributesEarningsBalanceAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesEarningsBalanceAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesEarningsBalanceAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesEarningsBalanceAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if a == nil {
		return []TransferDestinationCapability{}
	}
	return a.TransferDestination
}

// Details - An empty object for earnings balance accounts.
type Details struct {
}

func (d Details) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Details) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

// EarningsBalanceReadOnly - An account with type `EARNINGS_BALANCE` and subtype `ODP`.
type EarningsBalanceReadOnly struct {
	// A code that indicates the status of an account that is a destination for funds.
	AccountVerificationStatus AccountAttributesEarningsBalanceAccountVerificationStatus `json:"verification_status"`
	AccountBalances           AccountAttributesEarningsBalanceAccountBalances           `json:"balances"`
	AccountCapabilities       AccountAttributesEarningsBalanceAccountCapabilities       `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"EARNINGS_BALANCE" json:"account_type"`
	// The subtype of the account.
	subtype string `const:"ODP" json:"subtype"`
	// An empty object for earnings balance accounts.
	Details Details `json:"details"`
}

func (e EarningsBalanceReadOnly) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EarningsBalanceReadOnly) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (e *EarningsBalanceReadOnly) GetAccountVerificationStatus() AccountAttributesEarningsBalanceAccountVerificationStatus {
	if e == nil {
		return AccountAttributesEarningsBalanceAccountVerificationStatus("")
	}
	return e.AccountVerificationStatus
}

func (e *EarningsBalanceReadOnly) GetAccountBalances() AccountAttributesEarningsBalanceAccountBalances {
	if e == nil {
		return AccountAttributesEarningsBalanceAccountBalances{}
	}
	return e.AccountBalances
}

func (e *EarningsBalanceReadOnly) GetAccountCapabilities() AccountAttributesEarningsBalanceAccountCapabilities {
	if e == nil {
		return AccountAttributesEarningsBalanceAccountCapabilities{}
	}
	return e.AccountCapabilities
}

func (e *EarningsBalanceReadOnly) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EarningsBalanceReadOnly) GetAccountType() string {
	return "EARNINGS_BALANCE"
}

func (e *EarningsBalanceReadOnly) GetSubtype() string {
	return "ODP"
}

func (e *EarningsBalanceReadOnly) GetDetails() Details {
	if e == nil {
		return Details{}
	}
	return e.Details
}

// AccountAttributesCardAccountVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesCardAccountVerificationStatus string

const (
	AccountAttributesCardAccountVerificationStatusVerificationPending AccountAttributesCardAccountVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesCardAccountVerificationStatusVerificationFailed  AccountAttributesCardAccountVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesCardAccountVerificationStatusVerified            AccountAttributesCardAccountVerificationStatus = "VERIFIED"
)

func (e AccountAttributesCardAccountVerificationStatus) ToPointer() *AccountAttributesCardAccountVerificationStatus {
	return &e
}
func (e *AccountAttributesCardAccountVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesCardAccountVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardAccountVerificationStatus: %v", v)
	}
}

type AccountAttributesCardAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	// This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
	// **Special note for Earnings Balance accounts:**
	// If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesCardAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesCardAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"currency"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesCardAccountBalances) GetAvailable() *int64 {
	if a == nil {
		return nil
	}
	return a.Available
}

func (a *AccountAttributesCardAccountBalances) GetCurrent() *int64 {
	if a == nil {
		return nil
	}
	return a.Current
}

func (a *AccountAttributesCardAccountBalances) GetCurrency() string {
	if a == nil {
		return ""
	}
	return a.Currency
}

type AccountAttributesCardAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesCardAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesCardAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesCardAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if a == nil {
		return []TransferDestinationCapability{}
	}
	return a.TransferDestination
}

// AccountAttributesCardSubtype - The subtype of the account. Additional subtypes may be added over time
type AccountAttributesCardSubtype string

const (
	AccountAttributesCardSubtypeDebit    AccountAttributesCardSubtype = "DEBIT"
	AccountAttributesCardSubtypeDailypay AccountAttributesCardSubtype = "DAILYPAY"
)

func (e AccountAttributesCardSubtype) ToPointer() *AccountAttributesCardSubtype {
	return &e
}
func (e *AccountAttributesCardSubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DEBIT":
		fallthrough
	case "DAILYPAY":
		*e = AccountAttributesCardSubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardSubtype: %v", v)
	}
}

// CardAccountDetails - The banking details of the account and account holder.
type CardAccountDetails struct {
	// Last four digits of the card number.
	LastFour string `json:"last_four"`
	// The issuer of the card.
	Issuer string `json:"issuer"`
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The month of the expiration date for the card.
	ExpirationMonth string `json:"expiration_month"`
	// The year of the expiration date for the card.
	ExpirationYear string `json:"expiration_year"`
}

func (c CardAccountDetails) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardAccountDetails) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"last_four", "issuer", "first_name", "last_name", "expiration_month", "expiration_year"}); err != nil {
		return err
	}
	return nil
}

func (c *CardAccountDetails) GetLastFour() string {
	if c == nil {
		return ""
	}
	return c.LastFour
}

func (c *CardAccountDetails) GetIssuer() string {
	if c == nil {
		return ""
	}
	return c.Issuer
}

func (c *CardAccountDetails) GetFirstName() string {
	if c == nil {
		return ""
	}
	return c.FirstName
}

func (c *CardAccountDetails) GetLastName() string {
	if c == nil {
		return ""
	}
	return c.LastName
}

func (c *CardAccountDetails) GetExpirationMonth() string {
	if c == nil {
		return ""
	}
	return c.ExpirationMonth
}

func (c *CardAccountDetails) GetExpirationYear() string {
	if c == nil {
		return ""
	}
	return c.ExpirationYear
}

// Card - An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
type Card struct {
	// A code that indicates the status of an account that is a destination for funds.
	AccountVerificationStatus AccountAttributesCardAccountVerificationStatus `json:"verification_status"`
	AccountBalances           AccountAttributesCardAccountBalances           `json:"balances"`
	AccountCapabilities       AccountAttributesCardAccountCapabilities       `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"CARD" json:"account_type"`
	// The subtype of the account. Additional subtypes may be added over time
	Subtype AccountAttributesCardSubtype `json:"subtype"`
	// The banking details of the account and account holder.
	CardAccountDetails CardAccountDetails `json:"details"`
}

func (c Card) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Card) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (c *Card) GetAccountVerificationStatus() AccountAttributesCardAccountVerificationStatus {
	if c == nil {
		return AccountAttributesCardAccountVerificationStatus("")
	}
	return c.AccountVerificationStatus
}

func (c *Card) GetAccountBalances() AccountAttributesCardAccountBalances {
	if c == nil {
		return AccountAttributesCardAccountBalances{}
	}
	return c.AccountBalances
}

func (c *Card) GetAccountCapabilities() AccountAttributesCardAccountCapabilities {
	if c == nil {
		return AccountAttributesCardAccountCapabilities{}
	}
	return c.AccountCapabilities
}

func (c *Card) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *Card) GetAccountType() string {
	return "CARD"
}

func (c *Card) GetSubtype() AccountAttributesCardSubtype {
	if c == nil {
		return AccountAttributesCardSubtype("")
	}
	return c.Subtype
}

func (c *Card) GetCardAccountDetails() CardAccountDetails {
	if c == nil {
		return CardAccountDetails{}
	}
	return c.CardAccountDetails
}

type AccountAttributesType string

const (
	AccountAttributesTypeCard                    AccountAttributesType = "Card"
	AccountAttributesTypeEarningsBalanceReadOnly AccountAttributesType = "Earnings Balance (read only)"
	AccountAttributesTypeDepository              AccountAttributesType = "Depository"
)

// AccountAttributes - The details of the account.
type AccountAttributes struct {
	Card                    *Card                    `queryParam:"inline" union:"member"`
	EarningsBalanceReadOnly *EarningsBalanceReadOnly `queryParam:"inline" union:"member"`
	Depository              *Depository              `queryParam:"inline" union:"member"`

	Type AccountAttributesType
}

func CreateAccountAttributesCard(card Card) AccountAttributes {
	typ := AccountAttributesTypeCard

	return AccountAttributes{
		Card: &card,
		Type: typ,
	}
}

func CreateAccountAttributesEarningsBalanceReadOnly(earningsBalanceReadOnly EarningsBalanceReadOnly) AccountAttributes {
	typ := AccountAttributesTypeEarningsBalanceReadOnly

	return AccountAttributes{
		EarningsBalanceReadOnly: &earningsBalanceReadOnly,
		Type:                    typ,
	}
}

func CreateAccountAttributesDepository(depository Depository) AccountAttributes {
	typ := AccountAttributesTypeDepository

	return AccountAttributes{
		Depository: &depository,
		Type:       typ,
	}
}

func (u *AccountAttributes) UnmarshalJSON(data []byte) error {

	var card Card = Card{}
	if err := utils.UnmarshalJSON(data, &card, "", true, nil); err == nil {
		u.Card = &card
		u.Type = AccountAttributesTypeCard
		return nil
	}

	var earningsBalanceReadOnly EarningsBalanceReadOnly = EarningsBalanceReadOnly{}
	if err := utils.UnmarshalJSON(data, &earningsBalanceReadOnly, "", true, nil); err == nil {
		u.EarningsBalanceReadOnly = &earningsBalanceReadOnly
		u.Type = AccountAttributesTypeEarningsBalanceReadOnly
		return nil
	}

	var depository Depository = Depository{}
	if err := utils.UnmarshalJSON(data, &depository, "", true, nil); err == nil {
		u.Depository = &depository
		u.Type = AccountAttributesTypeDepository
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccountAttributes", string(data))
}

func (u AccountAttributes) MarshalJSON() ([]byte, error) {
	if u.Card != nil {
		return utils.MarshalJSON(u.Card, "", true)
	}

	if u.EarningsBalanceReadOnly != nil {
		return utils.MarshalJSON(u.EarningsBalanceReadOnly, "", true)
	}

	if u.Depository != nil {
		return utils.MarshalJSON(u.Depository, "", true)
	}

	return nil, errors.New("could not marshal union type AccountAttributes: all fields are null")
}
