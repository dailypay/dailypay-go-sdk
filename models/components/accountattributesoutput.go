// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/dailypay/dailypay-go-sdk/internal/utils"
)

// AccountAttributesDepositoryVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesDepositoryVerificationStatus string

const (
	AccountAttributesDepositoryVerificationStatusVerificationPending AccountAttributesDepositoryVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesDepositoryVerificationStatusVerificationFailed  AccountAttributesDepositoryVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesDepositoryVerificationStatusVerified            AccountAttributesDepositoryVerificationStatus = "VERIFIED"
)

func (e AccountAttributesDepositoryVerificationStatus) ToPointer() *AccountAttributesDepositoryVerificationStatus {
	return &e
}
func (e *AccountAttributesDepositoryVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesDepositoryVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositoryVerificationStatus: %v", v)
	}
}

type AccountAttributesDepositoryAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	//
	// **Special note for earnings_balance-type accounts:**
	// During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
	// the `current` balance will generally be 0, because transfers from earnings to this account will be
	// PENDING until the paycheck related to those earnings is processed.
	// Pending inflows are included in the `available` balance, not the `current` balance.
	//
	// If a user transfers money from an earnings_balance-type account to a personal account,
	// the `current` balance will be negative as those transfers settle. When a paycheck is processed,
	// DailyPay will automatically attempt to zero out the balance,
	// transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
	//
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
	// which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesDepositoryAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesDepositoryAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"currency"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesDepositoryAccountBalances) GetAvailable() *int64 {
	if a == nil {
		return nil
	}
	return a.Available
}

func (a *AccountAttributesDepositoryAccountBalances) GetCurrent() *int64 {
	if a == nil {
		return nil
	}
	return a.Current
}

func (a *AccountAttributesDepositoryAccountBalances) GetCurrency() string {
	if a == nil {
		return ""
	}
	return a.Currency
}

type AccountAttributesDepositoryAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesDepositoryAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesDepositoryAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesDepositoryAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if a == nil {
		return []TransferDestinationCapability{}
	}
	return a.TransferDestination
}

// AccountAttributesDepositorySubtype - The subtype of the account.
type AccountAttributesDepositorySubtype string

const (
	AccountAttributesDepositorySubtypeSavings  AccountAttributesDepositorySubtype = "SAVINGS"
	AccountAttributesDepositorySubtypeChecking AccountAttributesDepositorySubtype = "CHECKING"
)

func (e AccountAttributesDepositorySubtype) ToPointer() *AccountAttributesDepositorySubtype {
	return &e
}
func (e *AccountAttributesDepositorySubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SAVINGS":
		fallthrough
	case "CHECKING":
		*e = AccountAttributesDepositorySubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositorySubtype: %v", v)
	}
}

// DepositoryAccountDetails - The banking details of the account and account holder.
type DepositoryAccountDetails struct {
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The routing number of the bank that holds this account. Responses from this API that return this number are masked to the last four digits.
	RoutingNumber string `json:"routing_number"`
	// The account number. Responses from this API that return this number are masked to the last four digits.
	AccountNumber string `json:"account_number"`
}

func (d DepositoryAccountDetails) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DepositoryAccountDetails) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"first_name", "last_name", "routing_number", "account_number"}); err != nil {
		return err
	}
	return nil
}

func (d *DepositoryAccountDetails) GetFirstName() string {
	if d == nil {
		return ""
	}
	return d.FirstName
}

func (d *DepositoryAccountDetails) GetLastName() string {
	if d == nil {
		return ""
	}
	return d.LastName
}

func (d *DepositoryAccountDetails) GetRoutingNumber() string {
	if d == nil {
		return ""
	}
	return d.RoutingNumber
}

func (d *DepositoryAccountDetails) GetAccountNumber() string {
	if d == nil {
		return ""
	}
	return d.AccountNumber
}

// Depository - An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
type Depository struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesDepositoryVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesDepositoryAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesDepositoryAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"DEPOSITORY" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesDepositorySubtype `json:"subtype"`
	// The banking details of the account and account holder.
	DepositoryAccountDetails DepositoryAccountDetails `json:"details"`
}

func (d Depository) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Depository) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (d *Depository) GetVerificationStatus() AccountAttributesDepositoryVerificationStatus {
	if d == nil {
		return AccountAttributesDepositoryVerificationStatus("")
	}
	return d.VerificationStatus
}

func (d *Depository) GetAccountBalances() AccountAttributesDepositoryAccountBalances {
	if d == nil {
		return AccountAttributesDepositoryAccountBalances{}
	}
	return d.AccountBalances
}

func (d *Depository) GetAccountCapabilities() AccountAttributesDepositoryAccountCapabilities {
	if d == nil {
		return AccountAttributesDepositoryAccountCapabilities{}
	}
	return d.AccountCapabilities
}

func (d *Depository) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *Depository) GetAccountType() string {
	return "DEPOSITORY"
}

func (d *Depository) GetSubtype() AccountAttributesDepositorySubtype {
	if d == nil {
		return AccountAttributesDepositorySubtype("")
	}
	return d.Subtype
}

func (d *Depository) GetDepositoryAccountDetails() DepositoryAccountDetails {
	if d == nil {
		return DepositoryAccountDetails{}
	}
	return d.DepositoryAccountDetails
}

// AccountAttributesEarningsBalanceVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesEarningsBalanceVerificationStatus string

const (
	AccountAttributesEarningsBalanceVerificationStatusVerificationPending AccountAttributesEarningsBalanceVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesEarningsBalanceVerificationStatusVerificationFailed  AccountAttributesEarningsBalanceVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesEarningsBalanceVerificationStatusVerified            AccountAttributesEarningsBalanceVerificationStatus = "VERIFIED"
)

func (e AccountAttributesEarningsBalanceVerificationStatus) ToPointer() *AccountAttributesEarningsBalanceVerificationStatus {
	return &e
}
func (e *AccountAttributesEarningsBalanceVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesEarningsBalanceVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesEarningsBalanceVerificationStatus: %v", v)
	}
}

type AccountAttributesEarningsBalanceAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	//
	// **Special note for earnings_balance-type accounts:**
	// During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
	// the `current` balance will generally be 0, because transfers from earnings to this account will be
	// PENDING until the paycheck related to those earnings is processed.
	// Pending inflows are included in the `available` balance, not the `current` balance.
	//
	// If a user transfers money from an earnings_balance-type account to a personal account,
	// the `current` balance will be negative as those transfers settle. When a paycheck is processed,
	// DailyPay will automatically attempt to zero out the balance,
	// transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
	//
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
	// which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesEarningsBalanceAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesEarningsBalanceAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"currency"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesEarningsBalanceAccountBalances) GetAvailable() *int64 {
	if a == nil {
		return nil
	}
	return a.Available
}

func (a *AccountAttributesEarningsBalanceAccountBalances) GetCurrent() *int64 {
	if a == nil {
		return nil
	}
	return a.Current
}

func (a *AccountAttributesEarningsBalanceAccountBalances) GetCurrency() string {
	if a == nil {
		return ""
	}
	return a.Currency
}

type AccountAttributesEarningsBalanceAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesEarningsBalanceAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesEarningsBalanceAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesEarningsBalanceAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if a == nil {
		return []TransferDestinationCapability{}
	}
	return a.TransferDestination
}

// Details - An empty object for earnings balance accounts.
type Details struct {
}

func (d Details) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Details) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

// EarningsBalanceReadOnly - An account with type `EARNINGS_BALANCE` and subtype `ODP`.
type EarningsBalanceReadOnly struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesEarningsBalanceVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesEarningsBalanceAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesEarningsBalanceAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"EARNINGS_BALANCE" json:"account_type"`
	// The subtype of the account.
	subtype string `const:"ODP" json:"subtype"`
	// An empty object for earnings balance accounts.
	Details Details `json:"details"`
}

func (e EarningsBalanceReadOnly) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EarningsBalanceReadOnly) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (e *EarningsBalanceReadOnly) GetVerificationStatus() AccountAttributesEarningsBalanceVerificationStatus {
	if e == nil {
		return AccountAttributesEarningsBalanceVerificationStatus("")
	}
	return e.VerificationStatus
}

func (e *EarningsBalanceReadOnly) GetAccountBalances() AccountAttributesEarningsBalanceAccountBalances {
	if e == nil {
		return AccountAttributesEarningsBalanceAccountBalances{}
	}
	return e.AccountBalances
}

func (e *EarningsBalanceReadOnly) GetAccountCapabilities() AccountAttributesEarningsBalanceAccountCapabilities {
	if e == nil {
		return AccountAttributesEarningsBalanceAccountCapabilities{}
	}
	return e.AccountCapabilities
}

func (e *EarningsBalanceReadOnly) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EarningsBalanceReadOnly) GetAccountType() string {
	return "EARNINGS_BALANCE"
}

func (e *EarningsBalanceReadOnly) GetSubtype() string {
	return "ODP"
}

func (e *EarningsBalanceReadOnly) GetDetails() Details {
	if e == nil {
		return Details{}
	}
	return e.Details
}

// AccountAttributesCardVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesCardVerificationStatus string

const (
	AccountAttributesCardVerificationStatusVerificationPending AccountAttributesCardVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesCardVerificationStatusVerificationFailed  AccountAttributesCardVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesCardVerificationStatusVerified            AccountAttributesCardVerificationStatus = "VERIFIED"
)

func (e AccountAttributesCardVerificationStatus) ToPointer() *AccountAttributesCardVerificationStatus {
	return &e
}
func (e *AccountAttributesCardVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesCardVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardVerificationStatus: %v", v)
	}
}

type AccountAttributesCardAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	//
	// **Special note for earnings_balance-type accounts:**
	// During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
	// the `current` balance will generally be 0, because transfers from earnings to this account will be
	// PENDING until the paycheck related to those earnings is processed.
	// Pending inflows are included in the `available` balance, not the `current` balance.
	//
	// If a user transfers money from an earnings_balance-type account to a personal account,
	// the `current` balance will be negative as those transfers settle. When a paycheck is processed,
	// DailyPay will automatically attempt to zero out the balance,
	// transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
	//
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
	// which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesCardAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesCardAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"currency"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesCardAccountBalances) GetAvailable() *int64 {
	if a == nil {
		return nil
	}
	return a.Available
}

func (a *AccountAttributesCardAccountBalances) GetCurrent() *int64 {
	if a == nil {
		return nil
	}
	return a.Current
}

func (a *AccountAttributesCardAccountBalances) GetCurrency() string {
	if a == nil {
		return ""
	}
	return a.Currency
}

type AccountAttributesCardAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesCardAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesCardAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (a *AccountAttributesCardAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if a == nil {
		return []TransferDestinationCapability{}
	}
	return a.TransferDestination
}

// AccountAttributesCardSubtype - The subtype of the account. Additional subtypes may be added over time
type AccountAttributesCardSubtype string

const (
	AccountAttributesCardSubtypeDebit    AccountAttributesCardSubtype = "DEBIT"
	AccountAttributesCardSubtypeDailypay AccountAttributesCardSubtype = "DAILYPAY"
)

func (e AccountAttributesCardSubtype) ToPointer() *AccountAttributesCardSubtype {
	return &e
}
func (e *AccountAttributesCardSubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DEBIT":
		fallthrough
	case "DAILYPAY":
		*e = AccountAttributesCardSubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardSubtype: %v", v)
	}
}

// CardAccountDetailsOutput - The banking details of the account and account holder.
type CardAccountDetailsOutput struct {
	// Last four digits of the card number.
	LastFour string `json:"last_four"`
	// The issuer of the card.
	Issuer string `json:"issuer"`
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The month of the expiration date for the card.
	ExpirationMonth string `json:"expiration_month"`
	// The year of the expiration date for the card.
	ExpirationYear string `json:"expiration_year"`
}

func (c CardAccountDetailsOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardAccountDetailsOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"last_four", "issuer", "first_name", "last_name", "expiration_month", "expiration_year"}); err != nil {
		return err
	}
	return nil
}

func (c *CardAccountDetailsOutput) GetLastFour() string {
	if c == nil {
		return ""
	}
	return c.LastFour
}

func (c *CardAccountDetailsOutput) GetIssuer() string {
	if c == nil {
		return ""
	}
	return c.Issuer
}

func (c *CardAccountDetailsOutput) GetFirstName() string {
	if c == nil {
		return ""
	}
	return c.FirstName
}

func (c *CardAccountDetailsOutput) GetLastName() string {
	if c == nil {
		return ""
	}
	return c.LastName
}

func (c *CardAccountDetailsOutput) GetExpirationMonth() string {
	if c == nil {
		return ""
	}
	return c.ExpirationMonth
}

func (c *CardAccountDetailsOutput) GetExpirationYear() string {
	if c == nil {
		return ""
	}
	return c.ExpirationYear
}

// CardOutput - An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
type CardOutput struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesCardVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesCardAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesCardAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"CARD" json:"account_type"`
	// The subtype of the account. Additional subtypes may be added over time
	Subtype AccountAttributesCardSubtype `json:"subtype"`
	// The banking details of the account and account holder.
	CardAccountDetails CardAccountDetailsOutput `json:"details"`
}

func (c CardOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (c *CardOutput) GetVerificationStatus() AccountAttributesCardVerificationStatus {
	if c == nil {
		return AccountAttributesCardVerificationStatus("")
	}
	return c.VerificationStatus
}

func (c *CardOutput) GetAccountBalances() AccountAttributesCardAccountBalances {
	if c == nil {
		return AccountAttributesCardAccountBalances{}
	}
	return c.AccountBalances
}

func (c *CardOutput) GetAccountCapabilities() AccountAttributesCardAccountCapabilities {
	if c == nil {
		return AccountAttributesCardAccountCapabilities{}
	}
	return c.AccountCapabilities
}

func (c *CardOutput) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CardOutput) GetAccountType() string {
	return "CARD"
}

func (c *CardOutput) GetSubtype() AccountAttributesCardSubtype {
	if c == nil {
		return AccountAttributesCardSubtype("")
	}
	return c.Subtype
}

func (c *CardOutput) GetCardAccountDetails() CardAccountDetailsOutput {
	if c == nil {
		return CardAccountDetailsOutput{}
	}
	return c.CardAccountDetails
}

type AccountAttributesOutputType string

const (
	AccountAttributesOutputTypeCardOutput              AccountAttributesOutputType = "Card_output"
	AccountAttributesOutputTypeEarningsBalanceReadOnly AccountAttributesOutputType = "Earnings Balance (read only)"
	AccountAttributesOutputTypeDepository              AccountAttributesOutputType = "Depository"
)

// AccountAttributesOutput - The details of the account.
type AccountAttributesOutput struct {
	CardOutput              *CardOutput              `queryParam:"inline,name=AccountAttributes"`
	EarningsBalanceReadOnly *EarningsBalanceReadOnly `queryParam:"inline,name=AccountAttributes"`
	Depository              *Depository              `queryParam:"inline,name=AccountAttributes"`

	Type AccountAttributesOutputType
}

func CreateAccountAttributesOutputCardOutput(cardOutput CardOutput) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeCardOutput

	return AccountAttributesOutput{
		CardOutput: &cardOutput,
		Type:       typ,
	}
}

func CreateAccountAttributesOutputEarningsBalanceReadOnly(earningsBalanceReadOnly EarningsBalanceReadOnly) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeEarningsBalanceReadOnly

	return AccountAttributesOutput{
		EarningsBalanceReadOnly: &earningsBalanceReadOnly,
		Type:                    typ,
	}
}

func CreateAccountAttributesOutputDepository(depository Depository) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeDepository

	return AccountAttributesOutput{
		Depository: &depository,
		Type:       typ,
	}
}

func (u *AccountAttributesOutput) UnmarshalJSON(data []byte) error {

	var cardOutput CardOutput = CardOutput{}
	if err := utils.UnmarshalJSON(data, &cardOutput, "", true, nil); err == nil {
		u.CardOutput = &cardOutput
		u.Type = AccountAttributesOutputTypeCardOutput
		return nil
	}

	var earningsBalanceReadOnly EarningsBalanceReadOnly = EarningsBalanceReadOnly{}
	if err := utils.UnmarshalJSON(data, &earningsBalanceReadOnly, "", true, nil); err == nil {
		u.EarningsBalanceReadOnly = &earningsBalanceReadOnly
		u.Type = AccountAttributesOutputTypeEarningsBalanceReadOnly
		return nil
	}

	var depository Depository = Depository{}
	if err := utils.UnmarshalJSON(data, &depository, "", true, nil); err == nil {
		u.Depository = &depository
		u.Type = AccountAttributesOutputTypeDepository
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccountAttributesOutput", string(data))
}

func (u AccountAttributesOutput) MarshalJSON() ([]byte, error) {
	if u.CardOutput != nil {
		return utils.MarshalJSON(u.CardOutput, "", true)
	}

	if u.EarningsBalanceReadOnly != nil {
		return utils.MarshalJSON(u.EarningsBalanceReadOnly, "", true)
	}

	if u.Depository != nil {
		return utils.MarshalJSON(u.Depository, "", true)
	}

	return nil, errors.New("could not marshal union type AccountAttributesOutput: all fields are null")
}

// DepositoryInput - An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
type DepositoryInput struct {
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"DEPOSITORY" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesDepositorySubtype `json:"subtype"`
	// The banking details of the account and account holder.
	DepositoryAccountDetails DepositoryAccountDetails `json:"details"`
}

func (d DepositoryInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DepositoryInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (d *DepositoryInput) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *DepositoryInput) GetAccountType() string {
	return "DEPOSITORY"
}

func (d *DepositoryInput) GetSubtype() AccountAttributesDepositorySubtype {
	if d == nil {
		return AccountAttributesDepositorySubtype("")
	}
	return d.Subtype
}

func (d *DepositoryInput) GetDepositoryAccountDetails() DepositoryAccountDetails {
	if d == nil {
		return DepositoryAccountDetails{}
	}
	return d.DepositoryAccountDetails
}

// EarningsBalanceReadOnlyInput - An account with type `EARNINGS_BALANCE` and subtype `ODP`.
type EarningsBalanceReadOnlyInput struct {
}

func (e EarningsBalanceReadOnlyInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EarningsBalanceReadOnlyInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

// CardAccountDetailsInput - The banking details of the account and account holder.
type CardAccountDetailsInput struct {
	// A tokenized string replacement for the card data.
	Token string `json:"token"`
	// The issuer of the card.
	Issuer string `json:"issuer"`
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The month of the expiration date for the card.
	ExpirationMonth string `json:"expiration_month"`
	// The year of the expiration date for the card.
	ExpirationYear string `json:"expiration_year"`
	// The first line of the address for the card.
	AddressLineOne string `json:"address_line_one"`
	// The second line of the address for the card.
	AddressLineTwo *string `json:"address_line_two,omitempty"`
	// The city of the address for the card.
	AddressCity string `json:"address_city"`
	// The two-letter abbreviation of the state in the address for the card.
	AddressState string `json:"address_state"`
	// The zip code of the address for the card.
	AddressZipCode string `json:"address_zip_code"`
	// The country code of the address for the card.
	AddressCountry string `json:"address_country"`
}

func (c CardAccountDetailsInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardAccountDetailsInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"token", "issuer", "first_name", "last_name", "expiration_month", "expiration_year", "address_line_one", "address_city", "address_state", "address_zip_code", "address_country"}); err != nil {
		return err
	}
	return nil
}

func (c *CardAccountDetailsInput) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CardAccountDetailsInput) GetIssuer() string {
	if c == nil {
		return ""
	}
	return c.Issuer
}

func (c *CardAccountDetailsInput) GetFirstName() string {
	if c == nil {
		return ""
	}
	return c.FirstName
}

func (c *CardAccountDetailsInput) GetLastName() string {
	if c == nil {
		return ""
	}
	return c.LastName
}

func (c *CardAccountDetailsInput) GetExpirationMonth() string {
	if c == nil {
		return ""
	}
	return c.ExpirationMonth
}

func (c *CardAccountDetailsInput) GetExpirationYear() string {
	if c == nil {
		return ""
	}
	return c.ExpirationYear
}

func (c *CardAccountDetailsInput) GetAddressLineOne() string {
	if c == nil {
		return ""
	}
	return c.AddressLineOne
}

func (c *CardAccountDetailsInput) GetAddressLineTwo() *string {
	if c == nil {
		return nil
	}
	return c.AddressLineTwo
}

func (c *CardAccountDetailsInput) GetAddressCity() string {
	if c == nil {
		return ""
	}
	return c.AddressCity
}

func (c *CardAccountDetailsInput) GetAddressState() string {
	if c == nil {
		return ""
	}
	return c.AddressState
}

func (c *CardAccountDetailsInput) GetAddressZipCode() string {
	if c == nil {
		return ""
	}
	return c.AddressZipCode
}

func (c *CardAccountDetailsInput) GetAddressCountry() string {
	if c == nil {
		return ""
	}
	return c.AddressCountry
}

// CardInput - An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
type CardInput struct {
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"CARD" json:"account_type"`
	// The subtype of the account. Additional subtypes may be added over time
	Subtype AccountAttributesCardSubtype `json:"subtype"`
	// The banking details of the account and account holder.
	CardAccountDetails CardAccountDetailsInput `json:"details"`
}

func (c CardInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (c *CardInput) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CardInput) GetAccountType() string {
	return "CARD"
}

func (c *CardInput) GetSubtype() AccountAttributesCardSubtype {
	if c == nil {
		return AccountAttributesCardSubtype("")
	}
	return c.Subtype
}

func (c *CardInput) GetCardAccountDetails() CardAccountDetailsInput {
	if c == nil {
		return CardAccountDetailsInput{}
	}
	return c.CardAccountDetails
}

type AccountAttributesInputType string

const (
	AccountAttributesInputTypeCardInput                    AccountAttributesInputType = "Card_input"
	AccountAttributesInputTypeEarningsBalanceReadOnlyInput AccountAttributesInputType = "Earnings Balance (read only)_input"
	AccountAttributesInputTypeDepositoryInput              AccountAttributesInputType = "Depository_input"
)

// AccountAttributesInput - The details of the account.
type AccountAttributesInput struct {
	CardInput                    *CardInput                    `queryParam:"inline,name=AccountAttributes"`
	EarningsBalanceReadOnlyInput *EarningsBalanceReadOnlyInput `queryParam:"inline,name=AccountAttributes"`
	DepositoryInput              *DepositoryInput              `queryParam:"inline,name=AccountAttributes"`

	Type AccountAttributesInputType
}

func CreateAccountAttributesInputCardInput(cardInput CardInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeCardInput

	return AccountAttributesInput{
		CardInput: &cardInput,
		Type:      typ,
	}
}

func CreateAccountAttributesInputEarningsBalanceReadOnlyInput(earningsBalanceReadOnlyInput EarningsBalanceReadOnlyInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeEarningsBalanceReadOnlyInput

	return AccountAttributesInput{
		EarningsBalanceReadOnlyInput: &earningsBalanceReadOnlyInput,
		Type:                         typ,
	}
}

func CreateAccountAttributesInputDepositoryInput(depositoryInput DepositoryInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeDepositoryInput

	return AccountAttributesInput{
		DepositoryInput: &depositoryInput,
		Type:            typ,
	}
}

func (u *AccountAttributesInput) UnmarshalJSON(data []byte) error {

	var cardInput CardInput = CardInput{}
	if err := utils.UnmarshalJSON(data, &cardInput, "", true, nil); err == nil {
		u.CardInput = &cardInput
		u.Type = AccountAttributesInputTypeCardInput
		return nil
	}

	var depositoryInput DepositoryInput = DepositoryInput{}
	if err := utils.UnmarshalJSON(data, &depositoryInput, "", true, nil); err == nil {
		u.DepositoryInput = &depositoryInput
		u.Type = AccountAttributesInputTypeDepositoryInput
		return nil
	}

	var earningsBalanceReadOnlyInput EarningsBalanceReadOnlyInput = EarningsBalanceReadOnlyInput{}
	if err := utils.UnmarshalJSON(data, &earningsBalanceReadOnlyInput, "", true, nil); err == nil {
		u.EarningsBalanceReadOnlyInput = &earningsBalanceReadOnlyInput
		u.Type = AccountAttributesInputTypeEarningsBalanceReadOnlyInput
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccountAttributesInput", string(data))
}

func (u AccountAttributesInput) MarshalJSON() ([]byte, error) {
	if u.CardInput != nil {
		return utils.MarshalJSON(u.CardInput, "", true)
	}

	if u.EarningsBalanceReadOnlyInput != nil {
		return utils.MarshalJSON(u.EarningsBalanceReadOnlyInput, "", true)
	}

	if u.DepositoryInput != nil {
		return utils.MarshalJSON(u.DepositoryInput, "", true)
	}

	return nil, errors.New("could not marshal union type AccountAttributesInput: all fields are null")
}
